import sys
import logging
import shlex
from subprocess import PIPE
from argparse import ArgumentParser
from random import random

from shared.utils import subprocess_popen
from shared.interval_tree import bed_tree_from, is_region_in

logging.basicConfig(format='%(message)s', level=logging.INFO)


def Run(args):
    tree = bed_tree_from(bed_file_path=args.bed_fn)

    logging.info("Counting the number of Truth Variants in %s ..." % args.tensor_var_fn)
    v = 0
    d = {}
    f = subprocess_popen(shlex.split("gzip -fdc %s" % (args.tensor_var_fn)))
    for row in f.stdout:
        row = row.strip().split()
        ctgName = row[0]
        pos = int(row[1])
        key = "-".join([ctgName, str(pos)])
        v += 1
        d[key] = 1
    f.stdout.close()
    f.wait()

    logging.info("%d Truth Variants" % v)
    t = v * args.amp
    logging.info("%d non-variants to be picked" % t)

    logging.info("Counting the number of usable non-variants in %s ..." % args.tensor_can_fn)
    c = 0
    f = subprocess_popen(shlex.split("gzip -fdc %s" % (args.tensor_can_fn)))
    for row in f.stdout:
        row = row.strip().split()
        ctgName = row[0]
        pos = int(row[1])
        if args.bed_fn != None:
            if not is_region_in(tree, ctgName, pos):
                continue
        key = "-".join([ctgName, str(pos)])
        if key in d:
            continue
        c += 1
    f.stdout.close()
    f.wait()
    logging.info("%d usable non-variant" % c)

    r = float(t) / c
    r = r if r <= 1 else 1
    logging.info("%.2f of all non-variants are selected" % r)

    o1 = 0
    o2 = 0
    output_fpo = open(args.output_fn, "wb")
    output_fh = subprocess_popen(shlex.split("gzip -c"), stdin=PIPE, stdout=output_fpo)
    f = subprocess_popen(shlex.split("gzip -fdc %s" % (args.tensor_var_fn)))
    for row in f.stdout:
        row = row.strip()
        output_fh.stdin.write(row)
        output_fh.stdin.write("\n")
        o1 += 1
    f.stdout.close()
    f.wait()
    f = subprocess_popen(shlex.split("gzip -fdc %s" % (args.tensor_can_fn)))
    for row in f.stdout:
        rawRow = row.strip()
        row = rawRow.split()
        ctgName = row[0]
        pos = int(row[1])
        if args.bed_fn != None:
            if not is_region_in(tree, ctgName, pos):
                continue
        key = "-".join([ctgName, str(pos)])
        if key in d:
            continue
        if random() < r:
            output_fh.stdin.write(rawRow)
            output_fh.stdin.write("\n")
            o2 += 1
    f.stdout.close()
    f.wait()
    output_fh.stdin.close()
    output_fh.wait()
    output_fpo.close()
    logging.info("%.2f/%.2f Truth Variants/Non-variants outputed" % (o1, o2))


def main():
    parser = ArgumentParser(description="Predict and compare")

    parser.add_argument('--tensor_can_fn', type=str, default=None,
                        help="Tensors generated at randome genome positions by ExtractVariantCandidates.py+CreateTensor.py")

    parser.add_argument('--tensor_var_fn', type=str, default=None,
                        help="Variant tensors generated by GetTruth.py+CreateTensor.py")

    parser.add_argument('--bed_fn', type=str, default=None,
                        help="Usable genome regions input in BED format")

    parser.add_argument('--output_fn', type=str, default=None,
                        help="Tensors output filename")

    parser.add_argument('--amp', type=float, default=2,
                        help="Pick ((# of the Truth Variants)*amp) non-variants to pair with the Truth Variants, default: 2")

    args = parser.parse_args()

    if len(sys.argv[1:]) == 0:
        parser.print_help()
        sys.exit(1)

    Run(args)


if __name__ == "__main__":
    main()
